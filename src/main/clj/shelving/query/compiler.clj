(ns shelving.query.compiler
  "Implementation details of the shelving query compiler."
  {:authors ["Reid \"arrdem\" McKenzie <me@arrdem.com>"],
   :license "Eclipse Public License 1.0",
   :added   "0.0.0"}
  (:require [clojure.core.match :refer [match]]
            [shelving.core :as sh]
            [shelving.query.planner :as p]))

(defn compile-op
  "Implementation detail of `#'compile-clause`.

  Compiles a single `[lvar expr]` pair to a Clojure expression which
  consumes a sequence of lvar binding states and produces a sequence
  of lvar binding states.

  The free variable `conn` is assumed.

  It is assumed that the state sequence will be provided as the
  trailing argument ala by `->>`."
  {:stability  :stability/unstable
   :categories #{::sh/query}
   :added      "0.0.0"}
  [[lvar clause]] 
  (match clause
    {:type ::p/scan-rel, :rel rel, :id id}
    `(mapcat (fn [~'state]
               #_(println ~(str "DEBUG " (name lvar) " " (pr-str clause) "]\n        ") ~'state)
               (map (fn [~'e]
                      (assoc ~'state '~lvar ~'e))
                    (sh/relate-by-id ~'conn ~rel ~id))))

    {:type ::p/scan-spec :spec spec}
    `(mapcat (fn [~'state]
               #_(println ~(str "DEBUG " (name lvar) " " (pr-str clause) "]\n        ") ~'state)
               (map (fn [~'e]
                      (assoc ~'state '~lvar ~'e))
                    (sh/enumerate-spec ~'conn ~spec))))

    {:type ::p/project :rel rel :left left-var}
    `(mapcat (fn [~'state]
               #_(println ~(str "DEBUG " (name lvar) " " (pr-str clause) "]\n        ") ~'state)
               (map (fn [~'e]
                      (assoc ~'state '~lvar ~'e))
                    (sh/relate-by-id ~'conn ~rel (get ~'state '~left-var)))))

    {:type ::p/intersect :left left-var :right right-var}
    `(keep (fn [~'state]
             #_(println ~(str "DEBUG " (name lvar) " " (pr-str clause) "]\n        ") ~'state)
             (let [l# (get ~'state '~left-var)]
               (when (= l# (get ~'state '~right-var))
                 (merge ~'state {'~lvar l#})))))))

(defn compile-clause
  "Consumes a clause - being a sequence of scans, projects and
  intersects as generated by `#'shelving.query.planner/build-plan`, and
  produces a `(fn [state])` form implementing that set of logic
  relations and producing a logic variable state structure with the
  given `lvar` legally bound."
  {:stability  :stability/unstable
   :categories #{::sh/query}
   :added      "0.0.0"}
  [[lvar clauses]]
  `(fn ~lvar [~'states]
     (->> ~'states
          ~@(map compile-op clauses))))

(defn compile-plan
  "Implementation detail.

  Given a query plan, compile it to a directly executable stack of
  functions."
  {:stability  :stability/unstable
   :categories #{::sh/query}
   :added      "0.0.0"}
  [conn query-clauses select-lvar-specs]
  ;; And now for the tricky bit
  `(fn [~'conn ~'select-lvar-specs]
     (fn [~'states]
       (let [~@(mapcat (fn [[lvar :as clause]]
                         [lvar (compile-clause clause)]) query-clauses)]
         (->> ~'states ~@(map first query-clauses)
              (map (fn [state#]
                     (select-keys state# (keys ~'select-lvar-specs))))
              (map (fn [state#]
                     (->> (for [[lvar# spec#] ~'select-lvar-specs]
                            [lvar# (sh/get ~'conn spec# (get state# lvar#))])
                          (into {}))))))))) 
